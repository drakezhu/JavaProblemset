[
  {
    "id": 1,
    "category": "Java基础",
    "question": "什么是Java的多态？",
    "answer": "多态是指同一个方法调用可以根据对象的不同而表现出不同的行为。在Java中，多态通过方法重写和方法重载实现。方法重写是子类对父类方法的重新实现，方法重载是在同一个类中定义多个同名但参数列表不同的方法。",
    "difficulty": 1
  },
  {
    "id": 2,
    "category": "Java基础",
    "question": "Java中的HashMap和HashTable有什么区别？",
    "answer": "1. 线程安全性：HashMap非线程安全，HashTable线程安全\n2. 性能：HashMap性能更好，因为HashTable的方法都被synchronized修饰\n3. 允许的键值：HashMap允许null键和null值，HashTable不允许\n4. 继承关系：HashMap继承自AbstractMap，HashTable继承自Dictionary",
    "difficulty": 2
  },
  {
    "id": 3,
    "category": "Java基础",
    "question": "什么是Java的反射机制？",
    "answer": "反射是指在运行时动态获取类的信息并操作类的成员（字段、方法、构造器）的能力。通过反射，我们可以在运行时创建对象、调用方法、访问和修改字段值，而不需要在编译时知道类的具体信息。",
    "difficulty": 2
  },
  {
    "id": 4,
    "category": "集合框架",
    "question": "ArrayList和LinkedList的区别？",
    "answer": "1. 底层实现：ArrayList基于数组实现，LinkedList基于双向链表实现\n2. 访问效率：ArrayList随机访问效率高（O(1)），LinkedList随机访问效率低（O(n)）\n3. 插入删除效率：ArrayList插入删除元素需要移动其他元素，效率低（O(n)）；LinkedList插入删除元素只需要修改指针，效率高（O(1)）\n4. 内存占用：ArrayList内存占用较小，只存储元素本身；LinkedList内存占用较大，还需要存储前后指针",
    "difficulty": 1
  },
  {
    "id": 5,
    "category": "集合框架",
    "question": "HashMap的工作原理？",
    "answer": "HashMap基于哈希表实现，通过key的hashCode()计算哈希值，然后通过扰动函数和取模运算确定元素在数组中的位置。如果发生哈希冲突，使用链表或红黑树存储冲突的元素。Java 8中，当链表长度超过8且数组容量大于64时，会将链表转换为红黑树以提高查询效率。",
    "difficulty": 3
  },
  {
    "id": 6,
    "category": "多线程",
    "question": "什么是线程安全？如何实现线程安全？",
    "answer": "线程安全是指多个线程同时访问共享资源时，不会导致数据不一致或其他意外情况。实现线程安全的方式有：\n1. 使用synchronized关键字\n2. 使用Lock接口及其实现类\n3. 使用线程安全的集合类（如ConcurrentHashMap）\n4. 使用原子类（如AtomicInteger）\n5. 使用ThreadLocal\n6. 使用volatile关键字保证可见性",
    "difficulty": 2
  },
  {
    "id": 7,
    "category": "多线程",
    "question": "ThreadPoolExecutor的核心参数有哪些？",
    "answer": "ThreadPoolExecutor的核心参数包括：\n1. corePoolSize：核心线程数\n2. maximumPoolSize：最大线程数\n3. keepAliveTime：非核心线程的空闲存活时间\n4. unit：keepAliveTime的时间单位\n5. workQueue：工作队列，用于存储等待执行的任务\n6. threadFactory：线程工厂，用于创建线程\n7. handler：拒绝策略，当线程池和队列都满时的处理策略",
    "difficulty": 3
  },
  {
    "id": 8,
    "category": "Spring框架",
    "question": "Spring IoC容器的作用是什么？",
    "answer": "Spring IoC（Inversion of Control）容器的作用是管理Bean的生命周期和依赖注入。它将对象的创建、初始化、依赖关系的管理等工作从代码中分离出来，由容器统一管理，实现了控制反转。这样可以减少代码耦合，提高代码的可测试性和可维护性。",
    "difficulty": 2
  },
  {
    "id": 9,
    "category": "Spring框架",
    "question": "Spring AOP的实现原理？",
    "answer": "Spring AOP基于动态代理实现，有两种方式：\n1. 对于实现了接口的类，使用JDK动态代理\n2. 对于没有实现接口的类，使用CGLIB动态代理\nAOP通过切面（Aspect）、连接点（Join Point）、通知（Advice）、切点（Pointcut）等概念，将横切关注点（如日志、事务、安全等）从业务逻辑中分离出来，实现了代码的模块化和复用。",
    "difficulty": 3
  },
  {
    "id": 10,
    "category": "数据库",
    "question": "什么是索引？索引的优缺点？",
    "answer": "索引是数据库中用于提高查询效率的数据结构，它可以快速定位到数据所在的位置。\n优点：\n1. 提高查询效率\n2. 加速表之间的连接\n3. 强制数据唯一性\n缺点：\n1. 占用存储空间\n2. 降低插入、更新、删除操作的效率\n3. 索引需要维护，增加了数据库的负担",
    "difficulty": 2
  },
  {
    "id": 11,
    "category": "数据库",
    "question": "什么是事务？事务的ACID特性是什么？",
    "answer": "事务是数据库操作的一个逻辑单位，包含一组操作，这些操作要么全部成功，要么全部失败。\nACID特性：\n1. 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么全部成功，要么全部失败\n2. 一致性（Consistency）：事务执行前后，数据库的状态保持一致\n3. 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行\n4. 持久性（Durability）：事务一旦提交，其结果就是永久性的，即使系统发生故障也不会丢失",
    "difficulty": 2
  },
  {
    "id": 12,
    "category": "分布式",
    "question": "什么是分布式系统？分布式系统的特点？",
    "answer": "分布式系统是由多个独立的计算机组成的系统，这些计算机通过网络进行通信和协作，为用户提供统一的服务。\n特点：\n1. 分布性：系统由多个节点组成，分布在不同的地理位置\n2. 并发性：多个节点可以同时处理任务\n3. 透明性：用户无需知道系统的内部结构和实现细节\n4. 可靠性：单个节点的故障不会导致整个系统的崩溃\n5. 可扩展性：可以通过增加节点来提高系统的处理能力\n6. 一致性：多个节点之间需要保持数据的一致性",
    "difficulty": 3
  },
  {
    "id": 13,
    "category": "分布式",
    "question": "什么是CAP定理？",
    "answer": "CAP定理指出，在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）这三个特性最多只能同时满足两个。\n- 一致性：所有节点在同一时间看到相同的数据\n- 可用性：系统在任何时候都能响应请求\n- 分区容错性：系统在网络分区的情况下仍然能够正常工作\n在实际应用中，大多数分布式系统选择牺牲一致性来换取可用性和分区容错性，如Redis、Elasticsearch等。",
    "difficulty": 3
  },
  {
    "id": 14,
    "category": "Java基础",
    "question": "Java中的final关键字有什么作用？",
    "answer": "final关键字可以用于修饰类、方法和变量：\n1. 修饰类：表示该类不能被继承\n2. 修饰方法：表示该方法不能被重写\n3. 修饰变量：表示该变量一旦被初始化就不能再被修改\n  - 修饰局部变量：必须在使用前初始化，且一旦初始化就不能修改\n  - 修饰成员变量：必须在声明时或构造器中初始化，且一旦初始化就不能修改\n  - 修饰引用变量：引用本身不能修改，但引用指向的对象的内容可以修改",
    "difficulty": 1
  },
  {
    "id": 15,
    "category": "Java基础",
    "question": "Java中的异常体系是怎样的？",
    "answer": "Java的异常体系分为两大类：\n1. Error：表示严重的错误，程序一般无法处理，如OutOfMemoryError、StackOverflowError等\n2. Exception：表示程序可以处理的异常，分为：\n  - 检查型异常（Checked Exception）：必须在代码中显式处理，如IOException、SQLException等\n  - 非检查型异常（Unchecked Exception）：不需要显式处理，如NullPointerException、ArrayIndexOutOfBoundsException等\n\n所有异常都继承自Throwable类，Error和Exception是Throwable的直接子类。",
    "difficulty": 2
  },
  {
    "id": 16,
    "category": "集合框架",
    "question": "ConcurrentHashMap的工作原理？",
    "answer": "ConcurrentHashMap是线程安全的HashMap实现，主要特点：\n1. 分段锁：在Java 7及之前使用分段锁（Segment），每个Segment是一个小的HashMap\n2. 无锁算法：在Java 8中使用CAS+Synchronized，放弃了分段锁，使用Node数组+链表+红黑树的结构\n3. 高效并发：允许多个线程同时读，写操作只锁定当前操作的节点\n4. 性能优化：Java 8中使用红黑树提高查询效率，使用CAS减少锁竞争\n\nConcurrentHashMap的get操作是无锁的，put操作会在必要时锁定节点。",
    "difficulty": 3
  },
  {
    "id": 17,
    "category": "集合框架",
    "question": "LinkedHashMap和HashMap的区别？",
    "answer": "LinkedHashMap是HashMap的子类，主要区别：\n1. 有序性：LinkedHashMap维护了一个双向链表，保证了元素的插入顺序\n2. 性能：LinkedHashMap的插入、删除操作比HashMap略慢，因为需要维护双向链表\n3. 迭代顺序：LinkedHashMap的迭代顺序与插入顺序一致，HashMap的迭代顺序不确定\n4. 构造参数：LinkedHashMap可以通过构造参数accessOrder设置为按访问顺序排序\n\n当accessOrder为true时，LinkedHashMap会将最近访问的元素移到链表尾部，这种特性可以用于实现LRU缓存。",
    "difficulty": 2
  },
  {
    "id": 18,
    "category": "多线程",
    "question": "Java中的volatile关键字有什么作用？",
    "answer": "volatile关键字主要有两个作用：\n1. 可见性：确保当一个线程修改了volatile变量的值，其他线程能够立即看到这个修改\n2. 禁止指令重排序：防止编译器和处理器对volatile变量的操作进行重排序\n\nvolatile不能保证原子性，对于复合操作（如i++）仍然需要使用synchronized或原子类。",
    "difficulty": 2
  },
  {
    "id": 19,
    "category": "多线程",
    "question": "什么是线程池？为什么要使用线程池？",
    "answer": "线程池是一组预先创建的线程的集合，用于执行异步任务。使用线程池的好处：\n1. 减少线程创建和销毁的开销\n2. 控制并发线程数，避免资源耗尽\n3. 提高任务响应速度，任务可以直接从线程池中获取线程执行\n4. 便于管理和监控线程的状态\n\nJava中线程池的实现主要有ThreadPoolExecutor和Executors工具类提供的几种线程池。",
    "difficulty": 2
  },
  {
    "id": 20,
    "category": "Spring框架",
    "question": "Spring中的Bean生命周期是怎样的？",
    "answer": "Spring Bean的生命周期大致包括以下阶段：\n1. 实例化：创建Bean的实例\n2. 属性注入：设置Bean的属性值\n3. 初始化前：调用BeanPostProcessor的postProcessBeforeInitialization方法\n4. 初始化：调用Bean的初始化方法（如@PostConstruct注解的方法或init-method指定的方法）\n5. 初始化后：调用BeanPostProcessor的postProcessAfterInitialization方法\n6. 使用：Bean可以被应用程序使用\n7. 销毁：容器关闭时，调用Bean的销毁方法（如@PreDestroy注解的方法或destroy-method指定的方法）\n\n这个生命周期由Spring容器管理，可以通过各种扩展点进行自定义。",
    "difficulty": 3
  },
  {
    "id": 21,
    "category": "Spring框架",
    "question": "Spring中的依赖注入有哪些方式？",
    "answer": "Spring中的依赖注入主要有三种方式：\n1. 构造器注入：通过构造方法注入依赖\n2. Setter方法注入：通过setter方法注入依赖\n3. 字段注入：通过@Autowired注解直接注入到字段上\n\n构造器注入的优点是确保依赖在对象创建时就被初始化，避免了空指针异常的风险。Setter方法注入的优点是可以在运行时修改依赖。字段注入的优点是代码简洁，但不利于单元测试。\n\nSpring 4.3+推荐使用构造器注入，特别是对于必需的依赖。",
    "difficulty": 2
  },
  {
    "id": 22,
    "category": "数据库",
    "question": "什么是数据库索引？索引的类型有哪些？",
    "answer": "数据库索引是一种数据结构，用于快速定位和访问数据库表中的数据。索引的类型包括：\n1. 主键索引：唯一标识表中的每一行，不能为空\n2. 唯一索引：确保索引列的值唯一，但可以为空\n3. 普通索引：最基本的索引，没有唯一性限制\n4. 组合索引：基于多个列创建的索引\n5. 全文索引：用于全文搜索\n6. 空间索引：用于地理空间数据\n\n索引的优点是提高查询效率，缺点是占用存储空间，且会降低插入、更新、删除操作的效率。",
    "difficulty": 2
  },
  {
    "id": 23,
    "category": "数据库",
    "question": "什么是SQL注入？如何防止SQL注入？",
    "answer": "SQL注入是一种常见的网络攻击方式，攻击者通过在用户输入中插入恶意SQL代码，使应用程序执行非预期的SQL语句。\n\n防止SQL注入的方法：\n1. 使用预处理语句（PreparedStatement）：参数化查询，将SQL语句和参数分开处理\n2. 使用存储过程：将SQL逻辑封装在数据库端\n3. 输入验证：对用户输入进行严格的验证和过滤\n4. 最小权限原则：数据库用户只授予必要的权限\n5. 使用ORM框架：如Hibernate、MyBatis等，它们会自动处理SQL注入问题\n\n其中，使用预处理语句是防止SQL注入的最有效方法。",
    "difficulty": 2
  },
  {
    "id": 24,
    "category": "分布式",
    "question": "什么是分布式锁？有哪些实现方式？",
    "answer": "分布式锁是在分布式系统中用于协调多个节点对共享资源访问的机制。实现方式包括：\n1. 基于数据库：使用数据库的唯一索引或行级锁实现\n2. 基于Redis：使用SETNX命令或RedLock算法实现\n3. 基于ZooKeeper：使用临时节点和监听机制实现\n\n分布式锁需要满足以下特性：\n- 互斥性：同一时间只能有一个线程持有锁\n- 可重入性：同一个线程可以多次获取同一把锁\n- 容错性：部分节点故障不影响锁的功能\n- 公平性：按请求顺序获取锁\n\nRedis实现的分布式锁性能较高，ZooKeeper实现的分布式锁可靠性较高。",
    "difficulty": 3
  },
  {
    "id": 25,
    "category": "分布式",
    "question": "什么是分布式事务？有哪些解决方案？",
    "answer": "分布式事务是指跨越多个服务或数据源的事务，需要保证所有操作要么全部成功，要么全部失败。\n\n解决方案包括：\n1. 两阶段提交（2PC）：分为准备阶段和提交阶段，由协调者协调各个参与者\n2. 三阶段提交（3PC）：在2PC的基础上增加了超时机制和预提交阶段，减少了阻塞时间\n3. TCC（Try-Confirm-Cancel）：基于业务逻辑的补偿机制\n4. 本地消息表：通过消息队列保证最终一致性\n5. 事务消息：使用支持事务的消息队列，如RocketMQ\n6. Saga模式：将长事务拆分为多个短事务，通过事件驱动和补偿机制保证最终一致性\n\n在实际应用中，通常会根据业务场景选择合适的解决方案，如对于强一致性要求高的场景使用2PC，对于最终一致性要求的场景使用本地消息表或Saga模式。",
    "difficulty": 3
  },
  {
    "id": 26,
    "category": "Java基础",
    "question": "Java中的static关键字有什么作用？",
    "answer": "static关键字可以用于修饰变量、方法和代码块：\n1. 修饰变量：表示静态变量，属于类而不是实例，所有实例共享同一个值\n2. 修饰方法：表示静态方法，可以直接通过类名调用，不需要创建实例\n3. 修饰代码块：表示静态代码块，在类加载时执行，只执行一次\n4. 修饰内部类：表示静态内部类，可以在不创建外部类实例的情况下创建内部类实例\n\n静态成员的生命周期与类的生命周期相同，而不是与实例的生命周期相同。",
    "difficulty": 1
  },
  {
    "id": 27,
    "category": "Java基础",
    "question": "Java中的抽象类和接口有什么区别？",
    "answer": "Java中抽象类和接口的主要区别：\n1. 抽象类：\n  - 可以包含抽象方法和非抽象方法\n  - 可以包含实例变量\n  - 可以有构造器\n  - 一个类只能继承一个抽象类\n  - 抽象类是对类的抽象，体现了is-a的关系\n\n2. 接口：\n  - 只能包含抽象方法（Java 8之前），Java 8之后可以包含默认方法和静态方法\n  - 只能包含常量（public static final）\n  - 没有构造器\n  - 一个类可以实现多个接口\n  - 接口是对行为的抽象，体现了like-a的关系\n\n在Java 8之后，接口和抽象类的界限变得模糊，但核心区别仍然存在。",
    "difficulty": 2
  },
  {
    "id": 28,
    "category": "集合框架",
    "question": "TreeMap和HashMap的区别？",
    "answer": "TreeMap和HashMap的主要区别：\n1. 底层实现：\n  - HashMap：基于哈希表实现\n  - TreeMap：基于红黑树实现\n\n2. 有序性：\n  - HashMap：无序，不保证元素的存储顺序\n  - TreeMap：有序，默认按照键的自然顺序排序，也可以通过Comparator指定排序规则\n\n3. 性能：\n  - HashMap：插入、删除、查找操作的时间复杂度为O(1)\n  - TreeMap：插入、删除、查找操作的时间复杂度为O(log n)\n\n4. 键的要求：\n  - HashMap：键可以是任何对象，只要正确实现了hashCode()和equals()方法\n  - TreeMap：键必须实现Comparable接口，或者在构造时提供Comparator\n\n5. 空间占用：\n  - HashMap：空间占用相对较小\n  - TreeMap：空间占用相对较大，因为需要存储红黑树的结构\n\n如果需要有序的映射，使用TreeMap；如果需要更高的性能，使用HashMap。",
    "difficulty": 2
  },
  {
    "id": 29,
    "category": "集合框架",
    "question": "CopyOnWriteArrayList的工作原理？",
    "answer": "CopyOnWriteArrayList是Java并发包中的线程安全集合类，主要特点：\n1. 读写分离：读操作不需要加锁，直接读取当前数组\n2. 写时复制：写操作（添加、修改、删除）会创建一个新的数组，修改完成后将引用指向新数组\n3. 线程安全：写操作是原子的，通过ReentrantLock保证\n4. 适用场景：读多写少的场景，如配置管理、黑名单等\n\n优点：\n- 读操作无锁，性能高\n- 线程安全，不需要额外的同步措施\n\n缺点：\n- 写操作需要复制整个数组，内存占用大\n- 写操作性能低\n- 可能读取到旧数据（最终一致性）\n\nCopyOnWriteArrayList适用于读操作远多于写操作的场景，如日志系统、配置管理等。",
    "difficulty": 3
  },
  {
    "id": 30,
    "category": "多线程",
    "question": "Java中的CountDownLatch和CyclicBarrier有什么区别？",
    "answer": "CountDownLatch和CyclicBarrier都是Java并发包中的同步工具，主要区别：\n\n1. CountDownLatch：\n  - 计数递减到0后，无法重置\n  - 一个或多个线程等待，其他线程执行完成后唤醒等待线程\n  - 适用于：主线程等待多个子线程完成后再继续执行\n  - 调用countDown()方法递减计数\n  - 调用await()方法等待计数为0\n\n2. CyclicBarrier：\n  - 计数递减到0后，可以重置（通过reset()方法）\n  - 多个线程互相等待，直到所有线程都到达屏障点\n  - 适用于：多个线程需要在某个点同步后再继续执行\n  - 调用await()方法递减计数并等待\n  - 可以设置回调函数，当所有线程到达屏障点时执行\n\nCountDownLatch是一次性的，CyclicBarrier是可循环使用的。",
    "difficulty": 3
  },
  {
    "id": 31,
    "category": "多线程",
    "question": "Java中的ThreadLocal有什么作用？",
    "answer": "ThreadLocal是Java中用于创建线程本地变量的工具类：\n1. 作用：为每个线程创建一个独立的变量副本，线程之间互不影响\n2. 原理：内部使用ThreadLocalMap存储线程本地变量，ThreadLocalMap是Thread类的一个属性\n3. 使用场景：\n  - 存储线程上下文信息，如用户登录信息\n  - 避免参数传递，简化代码\n  - 数据库连接、Session管理等\n4. 注意事项：\n  - 可能导致内存泄漏，因为ThreadLocalMap的键是弱引用，但值是强引用\n  - 在使用完毕后应该调用remove()方法清理\n  - 不适合存储大对象，会增加内存占用\n\nThreadLocal提供了线程安全的方式来存储线程本地数据，避免了线程间的竞争。",
    "difficulty": 2
  },
  {
    "id": 32,
    "category": "Spring框架",
    "question": "Spring中的Bean作用域有哪些？",
    "answer": "Spring中Bean的作用域包括：\n1. singleton：单例模式，整个应用中只创建一个Bean实例（默认）\n2. prototype：原型模式，每次获取Bean时都创建一个新的实例\n3. request：每次HTTP请求创建一个新的Bean实例，仅在Web应用中有效\n4. session：每个HTTP会话创建一个新的Bean实例，仅在Web应用中有效\n5. application：整个Web应用创建一个Bean实例，仅在Web应用中有效\n6. websocket：每个WebSocket连接创建一个Bean实例，仅在Web应用中有效\n7. custom：自定义作用域\n\n在使用时，应该根据Bean的性质选择合适的作用域，如无状态Bean使用singleton，有状态Bean使用prototype。",
    "difficulty": 2
  },
  {
    "id": 33,
    "category": "Spring框架",
    "question": "Spring中的AOP有哪些应用场景？",
    "answer": "Spring AOP的主要应用场景包括：\n1. 日志记录：在方法执行前后记录日志\n2. 事务管理：在方法执行前后开启和提交事务\n3. 安全检查：在方法执行前进行权限验证\n4. 性能监控：记录方法执行时间\n5. 异常处理：统一处理方法执行过程中的异常\n6. 缓存：在方法执行前检查缓存，执行后更新缓存\n7. 数据校验：在方法执行前验证参数\n\nAOP通过将横切关注点从业务逻辑中分离出来，提高了代码的模块化和可维护性。",
    "difficulty": 2
  },
  {
    "id": 34,
    "category": "数据库",
    "question": "数据库的事务隔离级别有哪些？",
    "answer": "数据库的事务隔离级别包括：\n1. READ UNCOMMITTED（读未提交）：\n  - 允许读取未提交的数据\n  - 可能导致脏读、不可重复读、幻读\n\n2. READ COMMITTED（读已提交）：\n  - 只允许读取已提交的数据\n  - 解决了脏读问题，但可能导致不可重复读、幻读\n  - Oracle、SQL Server等默认隔离级别\n\n3. REPEATABLE READ（可重复读）：\n  - 保证在同一个事务中多次读取同一数据时结果一致\n  - 解决了脏读、不可重复读问题，但可能导致幻读\n  - MySQL默认隔离级别\n\n4. SERIALIZABLE（串行化）：\n  - 最高隔离级别，完全串行执行事务\n  - 解决了所有并发问题，但性能最低\n\n隔离级别越高，并发性能越低，需要根据业务场景选择合适的隔离级别。",
    "difficulty": 2
  },
  {
    "id": 35,
    "category": "数据库",
    "question": "什么是数据库的索引覆盖？",
    "answer": "索引覆盖是指查询语句的所有字段都包含在索引中，不需要回表查询数据：\n\n1. 原理：当查询的字段都在索引中时，数据库可以直接从索引中获取数据，而不需要再查询主键索引获取完整的行数据\n\n2. 优点：\n  - 减少IO操作，提高查询性能\n  - 避免回表查询，减少数据库负担\n\n3. 适用场景：\n  - 频繁查询的字段组合\n  - 字段较少的查询\n\n4. 实现方式：\n  - 创建包含查询所需所有字段的复合索引\n  - 确保查询的SELECT字段都在索引中\n\n索引覆盖是一种重要的性能优化手段，可以显著提高查询速度。",
    "difficulty": 3
  },
  {
    "id": 36,
    "category": "分布式",
    "question": "什么是服务发现？有哪些实现方式？",
    "answer": "服务发现是分布式系统中用于自动检测和管理服务实例的机制：\n\n1. 核心功能：\n  - 服务注册：服务实例启动时注册到服务注册中心\n  - 服务发现：客户端从服务注册中心获取服务实例列表\n  - 健康检查：定期检查服务实例的健康状态\n  - 服务下线：服务实例关闭时从注册中心移除\n\n2. 实现方式：\n  - 基于DNS：使用DNS记录管理服务实例\n  - 基于配置文件：手动维护服务实例列表\n  - 基于服务注册中心：如Eureka、Consul、ZooKeeper等\n\n3. 常见的服务注册中心：\n  - Eureka：Netflix开源，基于AP设计\n  - Consul：HashiCorp开源，基于CP设计，支持健康检查和DNS服务\n  - ZooKeeper：Apache开源，基于CP设计，用于分布式协调\n  - Nacos：阿里巴巴开源，支持AP和CP模式切换\n\n服务发现是微服务架构中的重要组件，解决了服务实例动态变化的问题。",
    "difficulty": 3
  },
  {
    "id": 37,
    "category": "分布式",
    "question": "什么是熔断机制？有哪些实现方式？",
    "answer": "熔断机制是分布式系统中用于防止服务雪崩的一种保护机制：\n\n1. 原理：当服务调用失败率达到阈值时，触发熔断，暂时停止对该服务的调用，直接返回降级响应\n\n2. 状态：\n  - 关闭（Closed）：正常状态，允许服务调用\n  - 打开（Open）：熔断状态，直接返回降级响应\n  - 半开（Half-Open）：尝试恢复状态，允许部分请求通过\n\n3. 实现方式：\n  - 基于计数器：记录失败次数，达到阈值触发熔断\n  - 基于时间窗口：在滑动时间窗口内统计失败率\n  - 基于状态机：管理熔断的不同状态\n\n4. 常见的实现框架：\n  - Hystrix：Netflix开源，已停止维护\n  - Sentinel：阿里巴巴开源，功能丰富\n  - Resilience4j：轻量级，基于Java 8，是Hystrix的替代方案\n\n熔断机制可以保护系统在服务依赖出现问题时不被拖垮，提高系统的可靠性和弹性。",
    "difficulty": 3
  },
    {
    "id": 38,
    "category": "JVM",
    "question": "JVM 的内存模型包括哪些区域？哪些是线程共享的，哪些是线程私有的？",
    "answer": "JVM 内存模型主要包括：\n1. 线程私有区域：\n   - 程序计数器（Program Counter Register）\n   - 虚拟机栈（Java Virtual Machine Stack）\n   - 本地方法栈（Native Method Stack）\n2. 线程共享区域：\n   - 堆（Heap）：存放对象实例，GC 主要区域\n   - 方法区（Method Area）：存储类信息、常量、静态变量等（JDK 8 后由 Metaspace 实现）\n\n堆和方法区是所有线程共享的，而程序计数器、虚拟机栈、本地方法栈每个线程独立拥有。",
    "difficulty": 2
  },
  {
    "id": 39,
    "category": "JVM",
    "question": "什么是 GC Roots？常见的 GC Roots 有哪些？",
    "answer": "GC Roots 是垃圾回收时的起点集合，从这些对象出发，通过引用链可达的对象被认为是存活的。\n\n常见的 GC Roots 包括：\n1. 虚拟机栈中局部变量表引用的对象\n2. 方法区中类静态属性引用的对象\n3. 方法区中常量引用的对象（如字符串常量池）\n4. 本地方法栈中 JNI（Native 方法）引用的对象\n5. 被同步锁（synchronized）持有的对象\n\n只有从 GC Roots 不可达的对象才会被回收。",
    "difficulty": 3
  },
  {
    "id": 40,
    "category": "Spring Boot",
    "question": "Spring Boot 的自动装配原理是什么？@SpringBootApplication 注解包含了哪些关键注解？",
    "answer": "@SpringBootApplication 是一个组合注解，包含：\n1. @SpringBootConfiguration：声明为配置类\n2. @EnableAutoConfiguration：启用自动装配\n3. @ComponentScan：组件扫描\n\n自动装配原理：\n- Spring Boot 启动时加载 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件\n- 该文件列出了所有自动配置类（如 DataSourceAutoConfiguration）\n- 通过 @ConditionalOnClass、@ConditionalOnMissingBean 等条件注解决定是否生效\n- 最终将符合条件的 Bean 注入容器",
    "difficulty": 3
  },
  {
    "id": 41,
    "category": "Spring Boot",
    "question": "如何在 Spring Boot 中实现自定义 Starter？",
    "answer": "实现自定义 Starter 的步骤：\n1. 创建一个 Maven 模块，命名以 -starter 结尾（如 my-spring-boot-starter）\n2. 添加自动配置类（如 MyServiceAutoConfiguration），使用 @Configuration + @Conditional 注解\n3. 在 resources/META-INF/spring 目录下创建 org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件\n4. 在文件中写入自动配置类的全限定名\n5. 将 Starter 发布到仓库，其他项目引入后即可自动装配\n\n优点：封装通用功能，提升开发效率，实现模块化复用。",
    "difficulty": 3
  },
  {
    "id": 42,
    "category": "Redis",
    "question": "Redis 为什么这么快？它的单线程模型是如何工作的？",
    "answer": "Redis 快的原因：\n1. 基于内存操作，避免磁盘 IO\n2. 单线程模型避免上下文切换和锁竞争\n3. 使用 I/O 多路复用（epoll/kqueue）处理高并发连接\n4. 高效的数据结构（如 SDS、跳跃表、压缩列表）\n\n单线程模型说明：\n- Redis 6.0 之前，网络 IO 和命令执行都在主线程\n- Redis 6.0 引入多线程用于网络 IO（读写 socket），但命令执行仍是单线程\n- 单线程保证了原子性，避免了并发问题\n- 性能瓶颈通常在网络或内存，而非 CPU",
    "difficulty": 2
  },
  {
    "id": 43,
    "category": "Redis",
    "question": "Redis 的持久化机制有哪些？RDB 和 AOF 各有什么优缺点？",
    "answer": "Redis 提供两种持久化机制：\n\n1. RDB（Redis Database）：\n   - 优点：文件紧凑，恢复速度快，适合备份\n   - 缺点：可能丢失最后一次快照后的数据\n\n2. AOF（Append Only File）：\n   - 优点：数据安全性高，可配置 fsync 策略\n   - 缺点：文件大，恢复慢\n\n生产环境建议：同时开启 RDB + AOF，AOF 作为主要持久化方式，RDB 用于定期备份。Redis 4.0+ 还支持混合持久化（aof-use-rdb-preamble yes），结合两者优势。",
    "difficulty": 2
  },
  {
    "id": 44,
    "category": "MySQL",
    "question": "MySQL 的 InnoDB 存储引擎有哪些核心特性？",
    "answer": "InnoDB 的核心特性包括：\n1. 支持事务（ACID）\n2. 行级锁（提高并发性能）\n3. MVCC（多版本并发控制，实现非阻塞读）\n4. 聚簇索引（主键索引的叶子节点存储完整行数据）\n5. 崩溃恢复（通过 redo log 和 undo log）\n6. 外键约束支持\n7. 支持全文索引（MySQL 5.6+）\n\nInnoDB 是 MySQL 5.5+ 的默认存储引擎，适用于高并发、事务型应用。",
    "difficulty": 2
  },
  {
    "id": 45,
    "category": "MySQL",
    "question": "什么是 MySQL 的慢查询日志？如何分析和优化慢 SQL？",
    "answer": "慢查询日志记录执行时间超过阈值的 SQL 语句。\n\n开启方式：\n- set global slow_query_log = on;\n- set global long_query_time = 1; （单位秒）\n\n分析工具：\n1. mysqldumpslow：官方分析工具\n2. pt-query-digest（Percona Toolkit）：更强大的分析能力\n\n优化步骤：\n1. 使用 EXPLAIN 分析执行计划\n2. 检查是否命中索引\n3. 避免 SELECT *，只查必要字段\n4. 优化 JOIN 条件和子查询\n5. 考虑分页优化（如延迟关联）\n6. 必要时进行表结构或索引调整",
    "difficulty": 3
  },
  {
    "id": 46,
    "category": "微服务",
    "question": "Spring Cloud Alibaba 中 Nacos 的核心功能有哪些？",
    "answer": "Nacos 是 Spring Cloud Alibaba 的核心组件，提供：\n1. 服务注册与发现：替代 Eureka，支持 AP/CP 切换\n2. 配置中心：动态管理配置，支持配置版本、灰度发布\n3. 服务健康检查：TCP/HTTP/MySQL 心跳检测\n4. 服务元数据管理：支持权重、集群、标签等\n5. 动态 DNS 服务：通过域名访问服务\n\n相比 Eureka + Config，Nacos 更轻量、功能更集成，适合国产化技术栈。",
    "difficulty": 2
  },
  {
    "id": 47,
    "category": "微服务",
    "question": "什么是 API 网关？Spring Cloud Gateway 的核心组件有哪些？",
    "answer": "API 网关是微服务架构的统一入口，提供路由转发、安全认证、限流熔断等功能。\n\nSpring Cloud Gateway 核心组件：\n1. Route（路由）：匹配规则和目标 URI\n2. Predicate（断言）：匹配 HTTP 请求（如 Path=/api/**）\n3. Filter（过滤器）：修改请求/响应（如添加 header、限流）\n\n工作流程：\n- 客户端请求 → Gateway Handler Mapping → 匹配 Route → 执行 Filters → 转发到目标服务\n\n优势：统一入口、解耦客户端与服务、增强安全性。",
    "difficulty": 2
  },
  {
    "id": 48,
    "category": "系统设计",
    "question": "如何设计一个全局唯一的分布式 ID 生成器？",
    "answer": "常用方案：\n1. UUID：简单但无序，影响数据库性能\n2. 数据库自增：单点瓶颈，扩展性差\n3. Redis INCR：性能好，但依赖 Redis 可用性\n4. Snowflake（雪花算法）：Twitter 开源，64 位 ID = 时间戳 + 机器 ID + 序列号\n   - 优点：趋势递增、高性能、无依赖\n   - 缺点：时钟回拨问题\n5. Leaf（美团开源）：基于 Snowflake 优化，解决时钟回拨\n\n推荐：Snowflake 或 Leaf，适用于高并发分布式场景。",
    "difficulty": 3
  },
  {
    "id": 49,
    "category": "系统设计",
    "question": "什么是缓存穿透、缓存击穿和缓存雪崩？分别如何解决？",
    "answer": "1. 缓存穿透：\n   - 问题：查询不存在的数据，绕过缓存直接打到 DB\n   - 解决：布隆过滤器 + 空值缓存（短 TTL）\n\n2. 缓存击穿：\n   - 问题：热点 key 过期瞬间，大量请求打到 DB\n   - 解决：互斥锁（Redis SETNX） + 逻辑过期\n\n3. 缓存雪崩：\n   - 问题：大量 key 同时过期，DB 瞬间压力剧增\n   - 解决：随机过期时间 + 多级缓存 + 服务熔断\n\n核心思想：避免缓存失效时流量直接冲击数据库。",
    "difficulty": 3
  },
  {
    "id": 50,
    "category": "消息队列",
    "question": "RocketMQ 如何保证消息不丢失？",
    "answer": "RocketMQ 通过以下方式保证消息不丢失：\n1. Producer 端：\n   - 使用同步发送（sendMessageSync）\n   - 开启 sendMsgTimeout 和 retryTimesWhenSendFailed\n2. Broker 端：\n   - 开启刷盘策略：同步刷盘（flushDiskType=SYNC_FLUSH）\n   - 主从架构：同步复制（brokerRole=SYNC_MASTER）\n3. Consumer 端：\n   - 手动 ACK（acknowledge）\n   - 处理异常时不要提交 offset\n\n注意：完全 100% 不丢消息会影响性能，需根据业务权衡可靠性与吞吐量。",
    "difficulty": 3
  },
  {
    "id": 51,
    "category": "安全",
    "question": "JWT（JSON Web Token）的工作原理是什么？如何防止令牌被盗用？",
    "answer": "JWT 结构：header.payload.signature\n- Header：算法和类型\n- Payload：用户信息、过期时间等\n- Signature：签名防篡改\n\n防止盗用措施：\n1. 设置较短的过期时间（exp）\n2. 使用 HTTPS 传输\n3. 敏感操作要求二次验证（如短信验证码）\n4. 实现 Token 黑名单（Redis 存储注销的 token）\n5. 绑定设备指纹或 IP（增强校验）\n\n注意：JWT 一旦签发无法主动失效，需结合黑名单机制。",
    "difficulty": 2
  },
  {
    "id": 52,
    "category": "DevOps",
    "question": "Docker 镜像的分层原理是什么？为什么能节省存储空间？",
    "answer": "Docker 镜像采用分层存储：\n1. 每条 Dockerfile 指令生成一个镜像层（Layer）\n2. 层是只读的，多个镜像可共享相同层\n3. 容器启动时，在镜像层之上加一个可写层（Container Layer）\n\n节省空间的原因：\n- 相同基础镜像（如 openjdk:17）只需存储一次\n- 构建新镜像时，只新增差异层\n- UnionFS（联合文件系统）将多层合并为单一视图\n\n例如：10 个基于 ubuntu 的镜像，ubuntu 层只存一份，总空间远小于 10 倍。",
    "difficulty": 2
  },
    {
    "id": 53,
    "category": "安全",
    "question": "Spring Security 的认证和授权流程是怎样的？",
    "answer": "Spring Security 的核心流程：\n1. 认证（Authentication）：\n   - 用户提交凭据（如用户名/密码）\n   - AuthenticationManager 调用 AuthenticationProvider\n   - Provider 查询 UserDetailsService 获取 UserDetails\n   - 验证密码（通过 PasswordEncoder）\n   - 成功后将 Authentication 对象存入 SecurityContext\n\n2. 授权（Authorization）：\n   - 请求到达时，FilterSecurityInterceptor 拦截\n   - 根据配置的权限规则（如 @PreAuthorize(\"hasRole('ADMIN')\")）\n   - 调用 AccessDecisionManager 决策是否放行\n\n整个过程基于过滤器链（Filter Chain）实现，可高度自定义。",
    "difficulty": 3
  },
  {
    "id": 54,
    "category": "ORM框架",
    "question": "MyBatis 中 #{} 和 ${} 的区别是什么？为什么推荐使用 #{}？",
    "answer": "#{} 和 ${} 的区别：\n1. #{}：\n   - 使用 PreparedStatement 预编译\n   - 自动处理类型转换和 SQL 注入防护\n   - 例如：WHERE id = #{id} → WHERE id = ?\n\n2. ${}：\n   - 直接字符串拼接\n   - 存在 SQL 注入风险\n   - 仅用于动态表名、列名等无法预编译的场景\n   - 例如：ORDER BY ${column}\n\n强烈推荐优先使用 #{}，只有在确实需要动态 SQL 结构时才谨慎使用 ${}，并配合输入校验。",
    "difficulty": 2
  },
  {
    "id": 55,
    "category": "ORM框架",
    "question": "MyBatis 的一级缓存和二级缓存有什么区别？",
    "answer": "1. 一级缓存（SqlSession 级别）：\n   - 默认开启\n   - 同一个 SqlSession 中多次查询相同语句，只查一次 DB\n   - SqlSession 关闭或执行 update/commit 后失效\n\n2. 二级缓存（Mapper 级别）：\n   - 需手动开启（<cache/> 或 @CacheNamespace）\n   - 多个 SqlSession 共享缓存（跨会话）\n   - 缓存对象必须实现 Serializable\n   - 更新操作会清空整个 Mapper 的缓存\n\n注意：二级缓存在高并发下可能引发脏读，需谨慎使用；分布式环境下建议用 Redis 替代。",
    "difficulty": 2
  },
  {
    "id": 56,
    "category": "网络",
    "question": "HTTP/1.1 和 HTTP/2 的主要区别是什么？",
    "answer": "HTTP/2 相比 HTTP/1.1 的改进：\n1. 二进制分帧：将报文拆分为 HEADERS、DATA 帧，提升解析效率\n2. 多路复用：单个 TCP 连接上并行传输多个请求/响应，避免队头阻塞\n3. 头部压缩：HPACK 算法减少重复 header 传输\n4. 服务器推送：服务端可主动推送资源到客户端缓存\n\n效果：减少连接数、降低延迟、提升页面加载速度。但 HTTP/2 仍基于 TCP，未解决队头阻塞根本问题（HTTP/3 用 QUIC 解决）。",
    "difficulty": 2
  },
  {
    "id": 57,
    "category": "网络",
    "question": "TCP 三次握手和四次挥手的过程是怎样的？为什么需要三次？",
    "answer": "三次握手（建立连接）：\n1. 客户端 → 服务端：SYN=1, seq=x\n2. 服务端 → 客户端：SYN=1, ACK=1, seq=y, ack=x+1\n3. 客户端 → 服务端：ACK=1, seq=x+1, ack=y+1\n\n为什么三次？防止历史连接请求突然到达服务端造成资源浪费（两次无法确认客户端是否收到服务端的 SYN-ACK）。\n\n四次挥手（关闭连接）：\n1. 主动方 → 被动方：FIN=1\n2. 被动方 → 主动方：ACK=1\n3. 被动方 → 主动方：FIN=1\n4. 主动方 → 被动方：ACK=1\n\n被动方可能还有数据要发送，所以不能合并第 2、3 步。",
    "difficulty": 2
  },
  {
    "id": 58,
    "category": "设计模式",
    "question": "Spring 中使用了哪些设计模式？请举例说明。",
    "answer": "Spring 框架广泛使用设计模式：\n1. 工厂模式：BeanFactory、ApplicationContext 创建 Bean\n2. 单例模式：默认作用域的 Bean 是单例\n3. 代理模式：AOP 使用 JDK 动态代理或 CGLIB 代理\n4. 模板方法：JdbcTemplate、RestTemplate 封装通用流程\n5. 观察者模式：事件监听机制（ApplicationEvent）\n6. 适配器模式：HandlerAdapter 适配不同 Controller 类型\n7. 装饰器模式：HttpServletRequestWrapper 扩展请求功能\n\n这些模式使 Spring 具备高内聚、低耦合、易扩展的特性。",
    "difficulty": 2
  },
  {
    "id": 59,
    "category": "设计模式",
    "question": "什么是策略模式？如何在支付系统中应用？",
    "answer": "策略模式定义一系列算法，封装每个算法，并使它们可互换。\n\n支付系统示例：\n1. 定义接口：PaymentStrategy\n2. 实现类：AlipayStrategy、WechatPayStrategy、UnionPayStrategy\n3. 上下文类：PaymentContext，持有 PaymentStrategy 引用\n4. 客户端根据用户选择（如 'alipay'）注入对应策略\n\n优点：\n- 新增支付方式无需修改主流程\n- 符合开闭原则\n- 代码结构清晰，易于测试",
    "difficulty": 2
  },
  {
    "id": 60,
    "category": "性能优化",
    "question": "如何排查 Java 应用的 CPU 使用率过高问题？",
    "answer": "排查步骤：\n1. top -Hp <pid>：找出占用 CPU 最高的线程 ID\n2. printf \"%x\\n\" <tid>：将十进制线程 ID 转为十六进制\n3. jstack <pid> | grep <hex_tid> -A 50：查看该线程堆栈\n4. 分析堆栈：\n   - 是否死循环？\n   - 是否频繁 Full GC？\n   - 是否正则回溯？\n   - 是否锁竞争激烈？\n\n辅助工具：\n- Arthas：在线诊断（thread -n 3）\n- async-profiler：生成火焰图\n- VisualVM：可视化分析\n\n关键：定位热点代码，而非盲目优化。",
    "difficulty": 3
  },
  {
    "id": 61,
    "category": "性能优化",
    "question": "Java 应用出现 Full GC 频繁，可能的原因有哪些？",
    "answer": "Full GC 频繁的常见原因：\n1. 老年代空间不足：对象晋升过快（如大对象直接进入老年代）\n2. Metaspace 不足：动态生成大量类（如反射、CGLIB）\n3. System.gc() 被显式调用（可通过 -XX:+DisableExplicitGC 禁用）\n4. 堆内存设置不合理：年轻代过小，导致对象快速进入老年代\n5. 内存泄漏：静态集合类持有对象引用不释放\n\n排查工具：\n- jstat -gc <pid>：监控 GC 统计\n- jmap -histo:live <pid>：查看存活对象分布\n- MAT（Memory Analyzer）：分析堆转储文件",
    "difficulty": 3
  },
  {
    "id": 62,
    "category": "日志与监控",
    "question": "如何实现 Java 应用的链路追踪（Trace）？",
    "answer": "链路追踪实现方案：\n1. 使用 OpenTelemetry 或 SkyWalking Agent\n2. 在入口（如 HTTP Filter）生成 TraceId 和 SpanId\n3. 通过 ThreadLocal 传递上下文\n4. 跨服务调用时，将 TraceId 放入 Header（如 X-B3-TraceId）\n5. 异步任务（如线程池、MQ）需手动传递上下文\n6. 数据上报到 Jaeger / Zipkin / SkyWalking UI\n\n关键点：\n- TraceId 全局唯一\n- Span 表示一个操作单元\n- 支持多级嵌套（Parent-Span）\n\n效果：可视化调用链，快速定位慢服务或异常节点。",
    "difficulty": 3
  },
  {
    "id": 63,
    "category": "日志与监控",
    "question": "Logback 和 Log4j2 的异同？为什么 Spring Boot 默认使用 Logback？",
    "answer": "相同点：\n- 都是 SLF4J 的实现\n- 支持异步日志、滚动策略、条件配置\n\n不同点：\n1. 性能：Log4j2 异步日志性能更高（Disruptor 队列）\n2. 配置：Log4j2 支持 XML、JSON、YAML；Logback 仅 XML\n3. 社区：Logback 由 log4j 创始人开发，与 SLF4j 深度集成\n\nSpring Boot 默认 Logback 的原因：\n- 与 SLF4j 无缝兼容\n- 配置简单，启动快\n- 满足大多数场景需求\n\n若追求极致性能（如高频交易），可切换为 Log4j2。",
    "difficulty": 2
  },
  {
    "id": 64,
    "category": "系统设计",
    "question": "如何设计一个高并发的秒杀系统？",
    "answer": "秒杀系统设计要点：\n1. 前端：\n   - 按钮置灰 + 验证码防刷\n   - 静态化商品页，CDN 加速\n2. 网关层：\n   - 限流（令牌桶/漏桶）\n   - 黑名单拦截\n3. 服务层：\n   - 库存预热到 Redis（DECR 原子操作）\n   - 异步下单（MQ 削峰）\n   - 分布式锁防超卖（Redis + Lua）\n4. 数据库：\n   - 库存字段加唯一索引\n   - 订单表分库分表\n\n核心原则：层层过滤，保护数据库，最终一致性。",
    "difficulty": 3
  },
  {
    "id": 65,
    "category": "系统设计",
    "question": "什么是 CQRS 架构？它适用于什么场景？",
    "answer": "CQRS（Command Query Responsibility Segregation）将写模型（Command）和读模型（Query）分离：\n- Command：处理写操作，更新领域模型\n- Query：处理读操作，直接查询专用读库（如 MySQL + Elasticsearch）\n\n优点：\n- 读写模型独立优化（如读库可冗余字段避免 JOIN）\n- 提升写吞吐量和读性能\n- 支持复杂查询（通过物化视图）\n\n适用场景：\n- 读写比例悬殊（如 100:1）\n- 读模型复杂（多维度筛选、聚合）\n- 需要高可用读服务\n\n挑战：数据最终一致性、系统复杂度增加。",
    "difficulty": 3
  }
]